// Copyright (c) 2016 Pani Networks
// All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may
// not use this file except in compliance with the License. You may obtain
// a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.
//
// IPtables save/restore based firewall implementations.

package firewall

import (
	"bytes"
	"net"
	"testing"

	"github.com/romana/core/agent/iptsave"
)

const (
	defaultRule = `
# Generated by iptables-save v1.4.21 on Tue Aug 30 12:21:37 2016
*filter
:INPUT ACCEPT [2258:359835]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [2202:367244]
:DOCKER - [0:0]
:DOCKER-ISOLATION - [0:0]
:KUBE-SERVICES - [0:0]
-A FORWARD -j DOCKER-ISOLATION
-A FORWARD -o docker0 -j DOCKER
-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -i docker0 ! -o docker0 -j ACCEPT
-A FORWARD -i docker0 -o docker0 -j ACCEPT
-A OUTPUT -m comment --comment "kubernetes service portals" -j KUBE-SERVICES
-A DOCKER-ISOLATION -j RETURN
COMMIT
`

	testRule1 = "OTHERCHAIN -p tcp -m tcp --dport 442 ! -m tcp --sport 443 -j ACCEPT"
	testRule2 = "MYCHAIN -p tcp -m tcp --dport 443 ! -m tcp --sport 442 -j OTHERCHAIN"
	testRule3 = "MYCHAIN -p tcp -m tcp --dport 80 ! -m tcp --sport 71 -j OTHERCHAIN"
)

/*
func TestInit(t *testing.T) {
	currentRules := iptsave.Parse(bytes.NewReader([]byte(defaultRule)))
}
*/

func TestSetDefaultRules(t *testing.T) {
	rules := []FirewallRule{}

	rules = append(rules, &IPtablesRule{Body: testRule1})
	rules = append(rules, &IPtablesRule{Body: testRule2})
	rules = append(rules, &IPtablesRule{Body: testRule3})

	firewall := IPTsaveFirewall{DesiredState: &iptsave.IPtables{}}
	firewall.DesiredState.Tables = append(firewall.DesiredState.Tables, &iptsave.IPtable{Name: "filter"})

	err := firewall.SetDefaultRules(rules)
	if err != nil {
		t.Error(err)
	}

	expect := `*filter
:MYCHAIN 
:OTHERCHAIN 
-A MYCHAIN -p tcp -m tcp --dport 443 ! -m tcp --sport 442 -j OTHERCHAIN 
-A MYCHAIN -p tcp -m tcp --dport 80 ! -m tcp --sport 71 -j OTHERCHAIN 
-A OTHERCHAIN -p tcp -m tcp --dport 442 ! -m tcp --sport 443 -j ACCEPT 
COMMIT`

	if len(firewall.DesiredState.Render()) != 253 {
		t.Errorf("expect %s\n got %s\n", firewall.DesiredState.Render(), expect)
	}
}

func TestSetEndpoint(t *testing.T) {
	firewall := IPTsaveFirewall{
		DesiredState:  &iptsave.IPtables{},
		CurrentState:  &iptsave.IPtables{},
		networkConfig: mockNetworkConfig{},
	}
	firewall.CurrentState.Parse(bytes.NewReader([]byte(defaultRule)))
	firewall.DesiredState.Tables = append(firewall.DesiredState.Tables, &iptsave.IPtable{Name: "filter"})

	if err := firewall.SetEndpoint(mockFirewallEndpoint{"eth0", "A", net.ParseIP("127.0.0.1")}); err != nil {
		t.Errorf("%s", err)
	}

	expect := `
*filter
:INPUT -
:OUTPUT -
:FORWARD -
:ROMANA-INPUT -
:ROMANA-FORWARD-OUT -
:ROMANA-FORWARD-IN -
-A INPUT -i eth -j ROMANA-INPUT
-A OUTPUT -o eth -j ROMANA-FORWARD-IN
-A FORWARD -i eth -j ROMANA-FORWARD-OUT
-A FORWARD -o eth -j ROMANA-FORWARD-IN
COMMIT`

	if len(firewall.DesiredState.Render()) != 263 {
		t.Errorf("expect %s\n got %s\n", expect, firewall.DesiredState.Render())
	}
}
